# https://www.acmicpc.net/problem/1715

"""
# 그리디 + 우선순위 큐
그리디 알고리즘은 현재 상황에서 최선의 선택을 반복하는 알고리즘
따라서 우선순위 큐를 사용하여 문제를 해결하는 경우가 흔함

# 문제
정렬된 두 묶음의 숫자 카드가 있다고 하자.
각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다.
이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.

매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다.
이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다.
예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면
(10 + 20) + (30 + 40) = 100번의 비교가 필요하다.
그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면
(10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.

N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

# 입력
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 10^5)
이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다.
숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.

# 시간제한: 2초
# 시간복잡도: O()

# 풀이
- 처음에는 구간합처럼 for문에서 cards[i] = cards[i-1] + cards[i]를 하고 print(sum(cards[1:]))을 했는데 아래 반례가 생김
- n=4, cards = [20, 30, 40, 45] 일 때, 20과 30을 더해서 50이 된 후 내 코드에서는 50과 40을 더해버리지만, 45와 40을 더해야 맞음(정렬이 흐트러짐)
- 즉 더해가는 와중에도 정렬이 항상 유지되어야만 함. 그래서 우선순위 큐를 사용해야 함!
"""

import sys
from queue import PriorityQueue

read = sys.stdin.readline

N = int(read())
bundles = PriorityQueue()

for _ in range(N):
    bundles.put(int(read()))

result = 0

while bundles.qsize() > 1:
    merged = bundles.get() + bundles.get()
    result += merged

    bundles.put(merged)

print(result)
