# https://www.acmicpc.net/problem/1328

"""
문제: N개의 빌딩을 왼쪽에서 봤을 때 보이는 빌딩의 개수가 L개, 오른쪽에서 봤을 때 보이는 빌딩의 개수가 R개가 되도록 빌딩을 배치하는 경우의 수를 구하는 프로그램을 작성하시오.

- d[n][l][r]: n개의 빌딩을 왼쪽에서 l개, 오른쪽에서 r개가 보이도록 배치하는 경우의 수
- 가장 작은 빌딩을 N번째 빌딩으로 놓는다고 가정하면
    - 1. 왼쪽에 배치 -> 왼쪽에서 보는 빌딩 수 1개 증가 : d[n-1][l-1][r]
    - 2. 오른쪽에 배치 -> 오른쪽에서 보는 빌딩 수 1개 증가 : d[n-1][l][r-1]
    - 3. 가운데에 배치 -> 양쪽에서 보는 빌딩 수는 증가하지 않음. 가운데에 배치할 수 있는 경우의 수 = n-2개 중 1개 선택 (빌딩 수(n) - 양끝(2)) : d[n-1][l][r] * (n-2)

- d[n][l][r] = d[n-1][l-1][r] + d[n-1][l][r-1] + d[n-1][l][r] * (n-2)
"""

n, l, r = map(int, input().split())  # n: 빌딩의 개수, l: 왼쪽에서 볼 때 보이는 빌딩의 개수, r: 오른쪽에서 볼 때 보이는 빌딩의 개수
mod = 1000000007

# d[i][j][k]: i번째 빌딩까지 놓는 경우의 수, 왼쪽에서 j개, 오른쪽에서 k개가 보이는 경우의 수
d = [[[0] * (r + 1) for _ in range(l + 1)] for _ in range(n + 1)]
d[1][1][1] = 1  # 1번째 빌딩을 놓는 경우의 수 (왼쪽에서 1개, 오른쪽에서 1개가 보이는 경우의 수)

for i in range(2, n + 1):  # 2번째 빌딩부터 n번째 빌딩까지
    for j in range(1, l + 1):
        for k in range(1, r + 1):
            d[i][j][k] = (d[i - 1][j - 1][k] + d[i - 1][j][k - 1] + d[i - 1][j][k] * (i - 2)) % mod

print(d[n][l][r])
