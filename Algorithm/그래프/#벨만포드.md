# 벨만-포드

## 개념

- 벨만-포드 알고리즘은 다익스트라 알고리즘과 유사하게 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘이다.
- 다익스트라 알고리즘과 다르게 에지의 가중치가 음수여도 된다.
- 벨만-포드 알고리즘은 다익스트라 알고리즘보다 느리지만 음수 가중치를 사용할 수 있다는 장점이 있다.
- 벨만-포드 알고리즘은 음수 사이클을 찾을 수 있다.
- 음수 사이클이란 에지의 가중치를 계속해서 더했을 때 음수가 되는 사이클을 말한다.
- 음수 사이클이 존재하면 최단 경로를 구할 수 없다.
- 벨만-포드 알고리즘은 다익스트라 알고리즘과 다르게 최단 경로를 구할 수 없는 경우가 존재한다.
- 벨만-포드 알고리즘은 다익스트라 알고리즘과 다르게 모든 정점을 시작 정점에서부터 거리를 저장한다.

## 단계

1. 초기화
    - **에지 리스트**로 그래프 구현
    - 최단 거리 리스트 초기화 (출발 노드는 0으로, 이외 노드는 무한(충분히 큰 값)으로 초기화)

2. 완화 (모든 에지를 확인해 최단 거리 리스트 업데이트)
    - 완화 작업: 현재 노드에서 연결된 에지의 값을 바탕으로 연결된 다음 노드의 최단 거리 리스트 값 업데이트
    - (정점 개수 - 1)번 완화 작업을 수행한다. -> 매 연산마다 최단 경로가 1개씩 확정되기 때문에

    1. dist[start] != sys.maxsize
        - 간선이 잇는 출발 노드가 방문된 적이 있어야 한다.
        - 출발 노드가 방문된 적이 없다 = 시작 노드(1번)에서 출발 노드로 가는 경로가 아직 없다. -> 갱신할 필요가 없다.
    2. dist[end] > dist[start] + time

3. 음수 사이클 검사
    - 모든 간선에 대해 한 번 더 완화 작업을 시도하여 거리 값이 더 줄어드는 경우가 있다면, 그래프에 음수 사이클이 존재한다는 것을 의미합니다. 음수 사이클이 있는 경우, 최단 경로는 정의될 수 없음.

벨만-포드 알고리즘의 시간 복잡도는 O(VE)입니다. (V는 정점의 수, E는 간선의 수)
이 알고리즘은 다익스트라 알고리즘보다 느리지만, 음수 가중치를 가진 간선이 포함된 그래프에서도 최단 경로를 찾을 수 있다는 장점이 있습니다.
따라서 응용 분야나 특정 상황에 따라 적절한 알고리즘을 선택할 수 있습니다.

## 구현

```python
def solution(graph, source):
    # ➊ 그래프의 노드 수
    num_vertices = len(graph)

    # ➋ 거리 배열 초기화
    distance = [float("inf")] * num_vertices
    distance[source] = 0

    # ➌ 직전 경로 배열 초기화
    predecessor = [None] * num_vertices

    # ➍ 간선 수 만큼 반복하여 최단 경로 갱신
    for temp in range(num_vertices - 1):
        for u in range(num_vertices):
            for v, weight in graph[u]:
                # ➎ 현재 노드 u를 거쳐서 노드 v로 가는 경로의 거리가 기존에 저장된 노드 v까지의 거리보다 짧은 경우
                if distance[u] + weight < distance[v]:
                    # ➏ 최단 거리를 갱신해줍니다.
                    distance[v] = distance[u] + weight
                    # ➐ 직전 경로를 업데이트합니다.
                    predecessor[v] = u

    # ➑ 음의 가중치 순회 체크
    for u in range(num_vertices):
        for v, weight in graph[u]:
            # ➒ 현재 노드 u를 거쳐서 노드 v로 가는 경로의 거리가 기존에 저장된 노드 v까지의 거리보다 짧은 경우
            if distance[u] + weight < distance[v]:
                # ❿ 음의 가중치 순회가 발견되었으므로 [-1]을 반환합니다.
                return [-1]
    return [distance, predecessor]


assert (solution([[(1, 4), (2, 3), (4, -6)], [(3, 5)], [(1, 2)], [(0, 7), (2, 4)], [(2, 2)]],
                 0) == [[0, -2, -4, 3, -6], [None, 2, 4, 1, 0]])
assert (solution([[(1, 5), (2, -1)], [(2, 2)], [(3, -2)], [(0, 2), (1, 6)]], 0) == [-1])
```